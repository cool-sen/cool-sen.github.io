<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Recording</title><link>https://cool-sen.github.io/posts/</link><description>Recent content in Posts on Recording</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 07 Jun 2020 20:15:47 +0800</lastBuildDate><atom:link href="https://cool-sen.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Kafka如何保证数据可靠性</title><link>https://cool-sen.github.io/posts/kafka-reliability/</link><pubDate>Sun, 07 Jun 2020 20:15:47 +0800</pubDate><guid>https://cool-sen.github.io/posts/kafka-reliability/</guid><description>本文从 Producter 往 Broker 发送消息、Topic 分区副本以及 Leader 选举几个角度介绍数据的可靠性。 Producer 发送消息 往 Kafka 对应的主题发送消息，我们需要通过 Producer 完成。Kafka</description></item><item><title>Kafka消费者组</title><link>https://cool-sen.github.io/posts/kafka-consumer-group/</link><pubDate>Sat, 06 Jun 2020 22:35:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/kafka-consumer-group/</guid><description>简介 消费者组是 Kafka 独有的概念，消费者组是 Kafka 提供的可扩展且具有容错性的消费者机制。 有多个消费者或消费者实例（Consumer Instance），</description></item><item><title>﻿Redis持久化策略</title><link>https://cool-sen.github.io/posts/redis-rdb-and-aof/</link><pubDate>Tue, 19 May 2020 21:13:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-rdb-and-aof/</guid><description>Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的持久化机制。 Redis 的持</description></item><item><title>﻿Redis过期策略和数据淘汰机制</title><link>https://cool-sen.github.io/posts/redis-expire/</link><pubDate>Mon, 18 May 2020 22:38:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-expire/</guid><description>过期策略 Redis 使用的过期键删除策略是惰性删除加上定期删除 redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 k</description></item><item><title>﻿Redis布隆过滤器</title><link>https://cool-sen.github.io/posts/redis-bloom-filter/</link><pubDate>Sun, 17 May 2020 21:15:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-bloom-filter/</guid><description>为什么用布隆过滤器 比如我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。问题来了，新闻</description></item><item><title>﻿Redis高级数据类型-Bitmap和HyperLogLog</title><link>https://cool-sen.github.io/posts/redis-advanced-data-types/</link><pubDate>Sat, 16 May 2020 20:18:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-advanced-data-types/</guid><description>位图 位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作</description></item><item><title>﻿Redis数据类型总结</title><link>https://cool-sen.github.io/posts/redis-summary-of-data-structure/</link><pubDate>Wed, 13 May 2020 21:15:11 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-summary-of-data-structure/</guid><description>redisObject 数据结构 redisObject 是 Redis 类型系统的核心， 数据库中的每个键、值，以及 Redis 本身处理的参数， 都表示为这种数据类型。 下图展示了 redisObject 、Redis 所有数据类型、以及</description></item><item><title>﻿Redis数据结构-跳跃表</title><link>https://cool-sen.github.io/posts/redis-skiplist/</link><pubDate>Tue, 12 May 2020 22:04:17 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-skiplist/</guid><description>跳表（skiplist）是一个特殊的链表，相比一般的链表，有更高的查找效率，其效率可比拟于二叉查找树。 跳跃表来源 跳跃表在 1990 年由 William Pugh 提出，而红</description></item><item><title>﻿Redis数据结构-压缩列表</title><link>https://cool-sen.github.io/posts/redis-ziplist/</link><pubDate>Sun, 10 May 2020 16:18:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-ziplist/</guid><description>Redis 为了节约内存空间使用，zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (ziplist) 进行存储。 ziplist是一个经过特殊编码的双向链表，它的设</description></item><item><title>Redis数据结构-字典</title><link>https://cool-sen.github.io/posts/redis-dict/</link><pubDate>Sat, 09 May 2020 21:14:37 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-dict/</guid><description>字典（dictionary）， 又名映射（map）或关联数组（associative array）是一种抽象数据结构， 由一集键值对（key-va</description></item><item><title>﻿Redis数据结构-简单动态字符串</title><link>https://cool-sen.github.io/posts/redis-sds/</link><pubDate>Fri, 08 May 2020 19:38:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/redis-sds/</guid><description>Sds （Simple Dynamic String，简单动态字符串）是 Redis 底层所使用的字符串表示， 几乎所有的 Redis 模块中都用了 sds。 sds 的用途 Sds 在 Redis 中的主要作用有以下</description></item><item><title>Spring-IOC-创建Bean-循环依赖处理</title><link>https://cool-sen.github.io/posts/ioc-createbean-4/</link><pubDate>Mon, 04 May 2020 18:34:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-createbean-4/</guid><description>1 简介 循环依赖并不仅仅只是在 doCreateBean 方法中处理，而是在整个加载 bean 的过程中都有涉及。所以，本文内容并不仅仅只局限于 doCreateBean 方法，而是从整个 Bean 的加载过程进行</description></item><item><title>Spring-IOC-创建Bean-属性填充</title><link>https://cool-sen.github.io/posts/ioc-createbean-3/</link><pubDate>Sun, 03 May 2020 17:35:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-createbean-3/</guid><description>1 简介 在Spring 创建 bean 的流程中，Spring 先通过反射创建一个原始的 bean 对象，然后再向这个原始的 bean 对象中填充属性。对于填充属性这个过程，简</description></item><item><title>创建bean的实例</title><link>https://cool-sen.github.io/posts/ioc-createbean-2/</link><pubDate>Sat, 02 May 2020 17:10:04 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-createbean-2/</guid><description>1 简介 本文将详细分析doCreateBean方法中的一个重要的调用，即createBeanInstance方法。先来了解一下方法的大致脉络。</description></item><item><title>IOC CreateBean</title><link>https://cool-sen.github.io/posts/ioc-create-bean/</link><pubDate>Fri, 01 May 2020 17:10:02 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-create-bean/</guid><description>createBean方法 createBean该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</description></item><item><title>﻿Spring-IoC -加载 Bean-总览</title><link>https://cool-sen.github.io/posts/ioc-get-bean-1/</link><pubDate>Thu, 23 Apr 2020 18:34:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-get-bean-1/</guid><description>2.1 获取 beanName 代码如下： 1 2 3 // AbstractBeanFactory.java final String beanName = transformedBeanName(name); 这段代码的作用：这里传递的是 name 方法，不一定就是 beanName，可能是 aliasName ，也有可能是 FactoryBean ，所以这里需要调</description></item><item><title>Spring-IOC-默认标签的解析</title><link>https://cool-sen.github.io/posts/ioc-load-beandefinitions-2/</link><pubDate>Sun, 19 Apr 2020 15:57:17 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-load-beandefinitions-2/</guid><description>前言 Spring中的标签包括默认标签和自定义标签两种，而两种标签的用法以及解析方式存在着很大的不同。本篇文章主要分析默认标签的解析。 默认标签</description></item><item><title>IOC XMLBeanDefinitionReader</title><link>https://cool-sen.github.io/posts/ioc-load-beandefinitions-1/</link><pubDate>Sat, 18 Apr 2020 18:34:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-load-beandefinitions-1/</guid><description>前言 1. Resource资源定位 Spring的配置文件读取是通过ClassPathResource进行封装的，如new ClassPathResource (&amp;quot;bean</description></item><item><title>Spring-IOC-从单例缓存中获取单例 Bean</title><link>https://cool-sen.github.io/posts/ioc-get-bean-getsingleton/</link><pubDate>Sat, 18 Apr 2020 18:34:57 +0800</pubDate><guid>https://cool-sen.github.io/posts/ioc-get-bean-getsingleton/</guid><description>获取单例Bean 1 getSingleton 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //DefaultSingletonBeanRegistry.java public Object getSingleton(String beanName) { // allowEarlyReference 参数，allowEarlyRefere</description></item><item><title>IDEA编译Spring源码</title><link>https://cool-sen.github.io/posts/spring-build-debugging-environment/</link><pubDate>Sat, 18 Apr 2020 10:56:03 +0800</pubDate><guid>https://cool-sen.github.io/posts/spring-build-debugging-environment/</guid><description>前言 相信大家都和我一样，想要阅读Spring源码。但是在编译Spring源码过程中，会遇到了很多坑，这个过程也实在让人心烦。下面我就把自己遇</description></item><item><title>Hugo搭建博客（二）— Hugo+Github Pages搭建博客</title><link>https://cool-sen.github.io/posts/hugo-build-environment-2/</link><pubDate>Tue, 14 Apr 2020 12:43:37 +0800</pubDate><guid>https://cool-sen.github.io/posts/hugo-build-environment-2/</guid><description>使用Hugo已经把博客搭建好了，那应该部署到哪里呢？可以使用VPS、云服务器等，我使用的是Github Pages，免费而且也很好用！ 我使用过</description></item><item><title>Hugo搭建博客（一）— 基本设置</title><link>https://cool-sen.github.io/posts/hugo-build-environment-1/</link><pubDate>Mon, 13 Apr 2020 19:42:16 +0800</pubDate><guid>https://cool-sen.github.io/posts/hugo-build-environment-1/</guid><description>1 安装Hugo 我在windows和ubuntu下安装过hugo，简要介绍下我的安装过程，其他方式可以参考官方文档 。 1.1 windows下安装 Hu</description></item></channel></rss>